//! OTP implementations based on [RFC 4226](https://www.rfc-editor.org/rfc/rfc4226) for Hmac-based OTPs
//! and [RFC 6238](https://www.rfc-editor.org/rfc/rfc6238) for Time-based OTPs.
//!
//! Out of the box you can generate and verify TOTPs and HOTPs using the default
//! algorithm SHA-1 and the default digit length of 6.
//!
//! If you need finer controls over password generation and verification, you can enable the `custom_otp` feature
//! flag to enable the [custom] module.
//!
//! The `encoding` feature flag gives access to the [encoding] module which provides 2 basic functions to encode
//! and decode the generated keys to an encoding of choice avilable from the [data_encoding](https://docs.rs/data-encoding/latest/data_encoding/index.html) crate.
//!
//! The `qr` feature flag enables QR code generation of the generated secret keys ready to be used by authenticator apps.
//!
//! ## Example usage
//!
//! ```
//! use thotp::{
//!     otp,
//!     verify_totp,
//!     time_step_now,
//!     generate_secret,
//!     encoding::{encode, decode},
//!     qr::generate_code,
//! };
//!
//! // Generate an encoded secret
//!
//! let secret = generate_secret(80);
//! let encoded = encode(&secret, data_encoding::BASE32);
//!  
//! // Store the secret somewhere safe
//!
//! let qr_code = generate_code(
//!     "totp",
//!     &encoded,
//!     "Big Corp:john.doe@email.com",
//!     "Big Corp",
//!     None,
//!     None,
//!     qrcode::EcLevel::M
//! )
//! .expect("uh oh");
//!
//! // Scan qr with some authenticator app
//!
//! // Verify a password provided from the client, assume this is what they calculated
//!
//! let pw = otp(&secret, time_step_now());
//!
//! let result = verify_totp(&pw, &secret, 0);
//!
//! assert!(result);
//! ```

#![crate_type = "lib"]

#[cfg(feature = "custom_otp")]
pub mod custom;

#[cfg(feature = "qr")]
pub mod qr;

use digest::{
    block_buffer::Eager,
    core_api::{BufferKindUser, CoreProxy, FixedOutputCore, UpdateCore},
    crypto_common::BlockSizeUser,
    typenum::{IsLess, Le, NonZero, U256},
    FixedOutput, HashMarker, Update,
};
use hmac::{Hmac, Mac};
use rand::{rngs::StdRng, RngCore, SeedableRng};
use sha1::Sha1;
use std::time::{SystemTime, UNIX_EPOCH};

/// Uses HMAC-SHA-1 and the default digit length of 6 to generate a one time password.
///
/// The security of the OTP generated by this function is as recommended by the RFC and should be
/// adequate for most intents and purposes. If you need finer control over how the
/// inputs are hashed or the digit length, use the `custom_otp` feature flag which provides functions with
/// more customizable parameters.
///
/// The `secret` is an arbitrary byte array (one can be generated with this crate's `generate_secret` function)
/// and the `nonce` is either a unix timestamp divided by the time step when dealing with TOTPs
///  or a counter when dealing with HOTPs.
///
/// The default verification functions use this function to create a password to compare to their inputs.
pub fn otp(secret: &[u8], nonce: u64) -> String {
    // Transform to bytes
    let nonce = &nonce.to_be_bytes();

    // Create an HMAC digest with the given key, nonce and algorithm
    let mut hmac = hmac_digest::<Sha1>(secret, nonce);

    // Truncate to 4 bytes
    let trunc = dynamic_trunc(&mut hmac);

    // Mod it with the default number of digits to get the password
    let mut result = (trunc % 10_u32.pow(DIGITS_DEFAULT as u32)).to_string();

    // Pad with 0s if the number is shorter than the necessary digits
    for i in 0..(DIGITS_DEFAULT as usize - result.len() as usize) {
        result.insert(i, '0');
    }

    result
}

/// Verifies the given password for the given timestamp and secret.
///
/// Uses SHA1, the default digit length of 6 and the default time step of 30
/// to generate a password to compare with the given one. If you need finer control
/// of the verification parameters, use the `custom_otp` feature flag.
///
/// The function considers passwords from the previous [ALLOWED_DRIFT] time slices
/// to be valid.
///
/// If a `timestamp` of 0 is provided, the current system time will be used for the calculation.
pub fn verify_totp(password: &str, secret: &[u8], timestamp: u64) -> bool {
    let nonce = if timestamp == 0 {
        time_step_now()
    } else {
        timestamp / TIME_STEP as u64
    };

    let start = nonce.saturating_sub(ALLOWED_DRIFT as u64);
    let end = nonce.saturating_add(ALLOWED_DRIFT as u64);

    for n in start..=end {
        let pass = otp(secret, n);
        if pass.eq(password) {
            return true;
        }
    }

    false
}

/// Generates multiple hotp passwords in the range of `lookahead + 1` and compares them to the input.
/// The counter wraps around on overflow.
/// A lookahead of 0 means only the current counter will be used in the verification.
///
/// Uses SHA1 and the default digit length of 6.
/// If you need finer control of the verification parameters, use the `custom_otp` feature flag.
///
/// If verification is successful the counter is incremented, otherwise it is left as is.
///
/// ## Example
/// ```
/// use thotp::{otp, verify_hotp};
///
/// let counter = 1;
/// let secret = b"super secret";
/// let password = otp(secret, counter);
///
/// let (result, counter) = verify_hotp(&password, secret, counter, 0);
///
/// assert_eq!(counter, 2);
/// assert!(result);
///
/// let (result, counter) = verify_hotp("fail", secret, counter, 0);
///
/// assert_eq!(counter, 2);
/// assert!(!result);
/// ```
pub fn verify_hotp(password: &str, secret: &[u8], counter: u64, lookahead: usize) -> (bool, u64) {
    for current in 0..lookahead + 1 {
        let curr = (counter as u128 + current as u128) as u64;

        let pass = otp(secret, curr);

        if pass.eq(password) {
            return (true, (curr as u128 + 1) as u64);
        }
    }

    (false, counter)
}

/// Generates a secret key, i.e. a buffer filled with random bytes. The RFC recommended buffer
/// size is 160, however some implementations use less.
pub fn generate_secret(size: usize) -> Vec<u8> {
    let mut key = vec![0; size];

    let mut rng = StdRng::from_entropy();

    rng.fill_bytes(&mut key);

    key
}

/// Generates a MAC of the secret key and nonce, hashed with the provided algorithm.
#[inline]
fn hmac_digest<H>(secret: &[u8], nonce: &[u8]) -> Vec<u8>
where
    H: Update + FixedOutput + CoreProxy,
    H::Core: HashMarker
        + UpdateCore
        + FixedOutputCore
        + BufferKindUser<BufferKind = Eager>
        + Default
        + Clone,
    <H::Core as BlockSizeUser>::BlockSize: IsLess<U256>,
    Le<<H::Core as BlockSizeUser>::BlockSize, U256>: NonZero,
{
    let mut mac = Hmac::<H>::new_from_slice(secret).expect("Unable to process MAC code");
    <Hmac<H> as Update>::update(&mut mac, nonce);
    mac.finalize().into_bytes().to_vec()
}

/// The dynamic truncate function as described in [RFC 4226](https://www.rfc-editor.org/rfc/rfc4226).
/// Determines an offset based on the last 4 bits of the input. The offset is then used as the starting index
/// of a slice of the input that spans 4 bytes. Finally, that slice is returned with the first bit masked to 0
/// resulting in a sequence of 31 bits. This function returns those 4 bytes in an u32, mitigating the need to
/// call the function str_to_num since it basically happens when we transform the byte array to an integer.
#[inline]
fn dynamic_trunc(input: &mut [u8]) -> u32 {
    // Grab the last 4 bits
    let offset = (input.last().unwrap() & 0xf) as usize;

    // Take a slice from the original bytes based on the offset
    let mut result: [u8; 4] = input[offset..=offset + 3].try_into().unwrap();

    // Mask the 32nd bit
    result[0] &= 0x7f;

    u32::from_be_bytes(result)
}

/// Calculates the number of seconds passed from the unix epoch divided by the default timestep.
#[inline]
pub fn time_step_now() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs()
        / TIME_STEP as u64
}

/// The default digits for OTP generation
pub const DIGITS_DEFAULT: u8 = 6;

/// The default and RFC recommended time step used to divide the duration in seconds from now
/// until the unix epoch.
pub const TIME_STEP: u8 = 30;

/// When TOTPs are generated, there is a chance they will be generated at the end of a time step and by
/// the time they reach the server the password would be invalid because it would fall in the previous
/// time step. This is mitigated by allowing passwords from `ALLOWED_DRIFT` time steps prior and subsequent
/// to the current to be valid. The value of this is the RFC recommended amount 1, meaning the passwords from the time slice
/// prior and subsequent to the current one are considered valid.
pub const ALLOWED_DRIFT: u8 = 1;

#[cfg(feature = "encoding")]
/// A simple module containing 2 functions to encode and decode the secrets generated by this crate's
/// `generate_secret` function to and from the given encoding available in the
/// [data_encoding](https://docs.rs/data-encoding/latest/data_encoding/index.html) crate.
///
///
/// ## Example
/// ```
/// use thotp::encoding::{encode, decode};
/// use thotp::generate_secret;
///
/// let buffer = generate_secret(160);
///
/// let encoded = encode(&buffer, data_encoding::BASE32);
///
/// let decoded: [u8; 160] = decode(&encoded, data_encoding::BASE32).try_into().unwrap();
///
/// assert_eq!(buffer, decoded)
/// ```
pub mod encoding {
    pub use data_encoding;
    use data_encoding::Encoding;

    /// Encodes the provided buffer to the encoding of choice. Useful for encoding secret
    /// buffers generated by this crate's `generate_secret` function.
    pub fn encode(buffer: &[u8], encoding: Encoding) -> String {
        encoding.encode(buffer)
    }

    /// Decodes the provided string from the encoding of choice. Useful for decoding
    /// encoded secrets generated with this crate's `generate_secret` and `encode` functions.
    pub fn decode(key: &str, encoding: Encoding) -> Vec<u8> {
        encoding
            .decode(key.as_bytes())
            .unwrap_or_else(|_| panic!("Couldn't decode key, make sure it's in {:?}", encoding))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use custom::*;
    use encoding::*;

    const TEST_KEY: &[u8; 20] = b"12345678901234567890";

    #[test]
    fn encode_decode() {
        let buffer = generate_secret(160);
        let encoded = encode(&buffer, data_encoding::BASE32);
        let decoded: [u8; 160] = decode(&encoded, data_encoding::BASE32).try_into().unwrap();
        assert_eq!(buffer, decoded)
    }

    #[test]
    fn hmac() {
        let hmac = super::hmac_digest::<Sha1>(b"12345678901234567890", b"1");
        assert!(hmac.len() == 20);

        let hmac = super::hmac_digest::<Sha256>(b"12345678901234567890123456789012", b"1");
        assert!(hmac.len() == 32);

        let hmac = super::hmac_digest::<Sha512>(
            b"1234567890123456789012345678901234567890123456789012345678901234",
            b"1",
        );
        assert!(hmac.len() == 64);
    }

    #[test]
    fn dynamic_trunc_() {
        let mut hmac = super::hmac_digest::<Sha1>(b"super secret key", b"1");
        assert_eq!(
            hmac,
            [
                104, 105, 130, 165, 155, 87, 155, 213, 180, 67, 104, 223, 123, 179, 211, 125, 173,
                78, 220, 226
            ]
        );

        // We know the last 4 bits will be taken as the offset
        let mask = 226 & 0x0f;
        assert_eq!(mask, 2);

        // Based on the offset we know the slice will be [130, 165, 155, 87]
        let res = dynamic_trunc(&mut hmac);

        // We also know the first bit will be masked, which in this case is the first bit of 130
        // and this will transform 130 to 2, the rest are hex representations of 165, 155 and 87
        assert_eq!(res, 0x02_a5_9b_57)
    }

    #[test]
    fn hotp_generation_verification() {
        let counter = 1;
        let password = otp(TEST_KEY, counter);
        let (result, counter) = verify_hotp(&password, TEST_KEY, counter, 0);
        assert_eq!(counter, 2);
        assert_eq!(result, true);

        let password = otp_custom::<Sha1>(TEST_KEY, counter, DIGITS_DEFAULT);
        let (result, counter) = verify_hotp(&password, TEST_KEY, counter, 0);
        assert_eq!(counter, 3);
        assert_eq!(result, true);

        let (result, counter) = verify_hotp("fail", TEST_KEY, counter, 0);
        assert_eq!(result, false);
        assert_eq!(counter, 3);

        // Test with lookahead and overflow
        let password = otp_custom::<Sha1>(TEST_KEY, counter, DIGITS_DEFAULT);
        let (result, counter) = verify_hotp(&password, TEST_KEY, u64::MAX, 20);
        assert_eq!(result, true);
        assert_eq!(counter, 4);

        let password = otp_custom::<Sha1>(TEST_KEY, u64::MAX - 1, DIGITS_DEFAULT);
        let (result, counter) = verify_hotp(&password, TEST_KEY, u64::MAX - 18, 20);
        assert_eq!(result, true);
        assert_eq!(counter, u64::MAX);

        // Sha1
        let password = otp_custom::<Sha1>(TEST_KEY, counter, DIGITS_DEFAULT);
        let (result, counter) = verify_hotp(&password, TEST_KEY, u64::MAX, 0);
        assert_eq!(result, true);
        assert_eq!(counter, 0);

        // Sha256
        let password = otp_custom::<Sha256>(TEST_KEY, u64::MAX - 1, DIGITS_DEFAULT);
        let (result, counter) =
            verify_hotp_custom::<Sha256>(&password, TEST_KEY, u64::MAX - 18, 20, DIGITS_DEFAULT);
        assert_eq!(result, true);
        assert_eq!(counter, u64::MAX);

        // Sha512
        let password = otp_custom::<Sha512>(TEST_KEY, u64::MAX - 1, DIGITS_DEFAULT);
        let (result, counter) =
            verify_hotp_custom::<Sha512>(&password, TEST_KEY, u64::MAX - 18, 20, DIGITS_DEFAULT);
        assert_eq!(result, true);
        assert_eq!(counter, u64::MAX);
    }

    // The values in the next 3 tests come from the RFC
    #[test]
    fn totp_sha1() {
        let secret: &[u8] = b"12345678901234567890";
        assert_eq!(20, secret.len());

        let pairs = vec![
            ("94287082", 59),
            ("07081804", 1111111109),
            ("14050471", 1111111111),
            ("89005924", 1234567890),
            ("69279037", 2000000000),
            ("65353130", 20000000000),
        ];

        pairs.into_iter().for_each(|(expected, timestamp)| {
            assert_eq!(
                expected,
                otp_custom::<Sha1>(secret, timestamp / TIME_STEP as u64, 8)
            );
            assert!(verify_totp_custom::<Sha1>(
                expected, secret, timestamp, 8, TIME_STEP, 1
            ));
        });
    }
    #[test]
    fn totp_sha256() {
        let secret: &[u8] = b"12345678901234567890123456789012";
        assert_eq!(32, secret.len());

        let pairs = vec![
            ("46119246", 59),
            ("68084774", 1111111109),
            ("67062674", 1111111111),
            ("91819424", 1234567890),
            ("90698825", 2000000000),
            ("77737706", 20000000000),
        ];

        pairs.into_iter().for_each(|(expected, timestamp)| {
            assert_eq!(
                expected,
                otp_custom::<Sha256>(secret, timestamp / TIME_STEP as u64, 8)
            );
            assert!(verify_totp_custom::<Sha256>(
                expected, secret, timestamp, 8, TIME_STEP, 1
            ));
        });
    }
    #[test]
    fn totp_sha512() {
        let secret: &[u8] = b"1234567890123456789012345678901234567890123456789012345678901234";
        assert_eq!(64, secret.len());

        let pairs = vec![
            ("90693936", 59),
            ("25091201", 1111111109),
            ("99943326", 1111111111),
            ("93441116", 1234567890),
            ("38618901", 2000000000),
            ("47863826", 20000000000),
        ];

        pairs.into_iter().for_each(|(expected, timestamp)| {
            assert_eq!(
                expected,
                otp_custom::<Sha512>(secret, timestamp / TIME_STEP as u64, 8)
            );
            assert!(verify_totp_custom::<Sha512>(
                expected, secret, timestamp, 8, TIME_STEP, 1
            ));
        });
    }
}
